/*

The idea is to think of the solution as a decision tree. 
In this tree the root is the given string. Every new state is generated by removing an edge. 
We will traverse this tree finding the valid strings on the lowest height.

    We will need:
        1 - A parentensis validation function.
        2 - The main traversal algorithm
 
 Example Tree:
                            "()())()"
        "())()"   "(())()"   "())()"   "()()()"   "()())"   -> the tree continues..
        

We must find ways to prune this tree otherwise we will TLE.

    Optimizations:
        1 - If we adapt the parenthesis validation function to return:
                0 = valid, 1 = invalid too much ')', -1 invalid too much '(' 
            In that way if we are already over on ')' we wont move to a children that removes another ')'
            
        2 - We will also keep a _maxLength variable which will have the biggest string found so far
            In that way we wont move to children that are smaller than this length.
            
        3 - We can keep a hashset of already visited elements (memoization) so we don't evaluate those string again.

*/
public class Solution {
    
    // Returns:
    // 0 = valid, 1 = invalid too much ')', -1 invalid too much '(' .
    private int CheckValid(string s) {        
        int opens = 0, closed = 0;
        foreach (char c in s){
            if (c == '(') 
                opens++;
            if (c == ')') 
                closed++;                       
            if ((opens - closed) < 0)
                return 1;
        }
        return (opens - closed) == 0? 0 : -1;
    }
    
    // The biggest valid string found. (Optimization 2)
    private int _maxLength = 0;
    // A memoization of the results found. (Optimization 3)
    private HashSet<string> _memo = new HashSet<string>();
    
    public IList<string> RemoveInvalidParentheses(string s) {
        
        int validation = CheckValid(s);
        
        // If this string is valid we return it.
        if (validation == 0 && s.Length >= _maxLength) {
            _maxLength = s.Length;
           return new List<string>(){s}; 
        }
                
        HashSet<string> ans = new HashSet<string>();
        
        // Generate possible strings.
        for (int i = 0; i < s.Length; i++ ) {    
            
            // Optimization 1 ( First tree prunning)
            if (s[i] == '(' && validation != -1) continue;
            if (s[i] == ')' && validation != 1) continue;
            if (s[i] != ')' && s[i] != '(') continue;
            
            // Remove a character
            string s2 = s.Remove(i,1);
            
            // Optimization 2 ( Second tree prunning)
            if (s2.Length < _maxLength) continue;
            
            // Optimization 3 ( Third tree prunning)
            if (!_memo.Add(s2)) continue;
            
            int lastLength = _maxLength;
            var result = RemoveInvalidParentheses(s2);
            
            // Found a bigger string.
            if (lastLength < _maxLength) 
                ans = new HashSet<string>(result);
            // Found same so I add.    
            if (lastLength == _maxLength)
                ans.UnionWith(result);   
        }
        return ans.ToList();
    }
}
